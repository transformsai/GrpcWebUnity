{
  "version": 3,
  "sources": ["../../../../Client/node_modules/src/index.ts", "../../../../Client/node_modules/@protobuf-ts/runtime/build/es2015/base64.js", "../../../../Client/node_modules/@protobuf-ts/runtime/build/es2015/assert.js", "../../../../Client/node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js", "../../../../Client/node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js", "../../../../Client/node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-error.js", "../../../../Client/node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-options.js", "../../../../Client/node_modules/@protobuf-ts/runtime-rpc/build/es2015/deferred.js", "../../../../Client/node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-output-stream.js", "../../../../Client/node_modules/@protobuf-ts/runtime-rpc/build/es2015/unary-call.js", "../../../../Client/node_modules/@protobuf-ts/runtime-rpc/build/es2015/server-streaming-call.js", "../../../../Client/node_modules/@protobuf-ts/grpcweb-transport/build/es2015/goog-grpc-status-code.js", "../../../../Client/node_modules/@protobuf-ts/grpcweb-transport/build/es2015/grpc-web-format.js", "../../../../Client/node_modules/@protobuf-ts/grpcweb-transport/build/es2015/grpc-web-transport.js", "../../../../Client/src/GrpcWebConnector/UnityProtoMessage.ts", "../../../../Client/src/GrpcWebConnector/Utils.ts", "../../../../Client/src/GrpcWebConnector/Call.ts", "../../../../Client/src/GrpcWebConnector/Channel.ts", "../../../../Client/src/GrpcWebConnector/Instance.ts", "../../../../Client/src/GrpcWebConnector/Delegator.ts", "../../../../Client/src/main.ts"],
  "sourcesContent": [null, "// lookup table from base64 character to byte\nlet encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor (let i = 0; i < encTable.length; i++)\n    decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\n/**\n * Decodes a base64 string to a byte array.\n *\n * - ignores white-space, including line breaks and tabs\n * - allows inner padding (can decode concatenated base64 strings)\n * - does not require padding\n * - understands base64url encoding:\n *   \"-\" instead of \"+\",\n *   \"_\" instead of \"/\",\n *   no padding\n */\nexport function base64decode(base64Str) {\n    // estimate byte size, not accounting for inner padding and whitespace\n    let es = base64Str.length * 3 / 4;\n    // if (es % 3 !== 0)\n    // throw new Error('invalid base64 string');\n    if (base64Str[base64Str.length - 2] == '=')\n        es -= 2;\n    else if (base64Str[base64Str.length - 1] == '=')\n        es -= 1;\n    let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n    groupPos = 0, // position in base64 group\n    b, // current byte\n    p = 0 // previous byte\n    ;\n    for (let i = 0; i < base64Str.length; i++) {\n        b = decTable[base64Str.charCodeAt(i)];\n        if (b === undefined) {\n            // noinspection FallThroughInSwitchStatementJS\n            switch (base64Str[i]) {\n                case '=':\n                    groupPos = 0; // reset state when padding found\n                case '\\n':\n                case '\\r':\n                case '\\t':\n                case ' ':\n                    continue; // skip white-space, and padding\n                default:\n                    throw Error(`invalid base64 string.`);\n            }\n        }\n        switch (groupPos) {\n            case 0:\n                p = b;\n                groupPos = 1;\n                break;\n            case 1:\n                bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                p = b;\n                groupPos = 2;\n                break;\n            case 2:\n                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                p = b;\n                groupPos = 3;\n                break;\n            case 3:\n                bytes[bytePos++] = (p & 3) << 6 | b;\n                groupPos = 0;\n                break;\n        }\n    }\n    if (groupPos == 1)\n        throw Error(`invalid base64 string.`);\n    return bytes.subarray(0, bytePos);\n}\n/**\n * Encodes a byte array to a base64 string.\n * Adds padding at the end.\n * Does not insert newlines.\n */\nexport function base64encode(bytes) {\n    let base64 = '', groupPos = 0, // position in base64 group\n    b, // current byte\n    p = 0; // carry over from previous byte\n    for (let i = 0; i < bytes.length; i++) {\n        b = bytes[i];\n        switch (groupPos) {\n            case 0:\n                base64 += encTable[b >> 2];\n                p = (b & 3) << 4;\n                groupPos = 1;\n                break;\n            case 1:\n                base64 += encTable[p | b >> 4];\n                p = (b & 15) << 2;\n                groupPos = 2;\n                break;\n            case 2:\n                base64 += encTable[p | b >> 6];\n                base64 += encTable[b & 63];\n                groupPos = 0;\n                break;\n        }\n    }\n    // padding required?\n    if (groupPos) {\n        base64 += encTable[p];\n        base64 += '=';\n        if (groupPos == 1)\n            base64 += '=';\n    }\n    return base64;\n}\n", "/**\n * assert that condition is true or throw error (with message)\n */\nexport function assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\n/**\n * assert that value cannot exist = type `never`. throw runtime error if it does.\n */\nexport function assertNever(value, msg) {\n    throw new Error(msg !== null && msg !== void 0 ? msg : 'Unexpected object: ' + value);\n}\nconst FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -3.4028234663852886e+38, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -0X80000000;\nexport function assertInt32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error('invalid int 32: ' + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)\n        throw new Error('invalid int 32: ' + arg);\n}\nexport function assertUInt32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error('invalid uint 32: ' + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)\n        throw new Error('invalid uint 32: ' + arg);\n}\nexport function assertFloat32(arg) {\n    if (typeof arg !== \"number\")\n        throw new Error('invalid float 32: ' + typeof arg);\n    if (!Number.isFinite(arg))\n        return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)\n        throw new Error('invalid float 32: ' + arg);\n}\n", "import { BinaryReader } from \"./binary-reader\";\nimport { BinaryWriter } from \"./binary-writer\";\n/**\n * This handler implements the default behaviour for unknown fields.\n * When reading data, unknown fields are stored on the message, in a\n * symbol property.\n * When writing data, the symbol property is queried and unknown fields\n * are serialized into the output again.\n */\nexport var UnknownFieldHandler;\n(function (UnknownFieldHandler) {\n    /**\n     * The symbol used to store unknown fields for a message.\n     * The property must conform to `UnknownFieldContainer`.\n     */\n    UnknownFieldHandler.symbol = Symbol(\"protobuf-ts/unknown\");\n    /**\n     * Store an unknown field during binary read directly on the message.\n     * This method is compatible with `BinaryReadOptions.readUnknownField`.\n     */\n    UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data) => {\n        let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];\n        container.push({ no: fieldNo, wireType, data });\n    };\n    /**\n     * Write unknown fields stored for the message to the writer.\n     * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.\n     */\n    UnknownFieldHandler.onWrite = (typeName, message, writer) => {\n        for (let { no, wireType, data } of UnknownFieldHandler.list(message))\n            writer.tag(no, wireType).raw(data);\n    };\n    /**\n     * List unknown fields stored for the message.\n     * Note that there may be multiples fields with the same number.\n     */\n    UnknownFieldHandler.list = (message, fieldNo) => {\n        if (is(message)) {\n            let all = message[UnknownFieldHandler.symbol];\n            return fieldNo ? all.filter(uf => uf.no == fieldNo) : all;\n        }\n        return [];\n    };\n    /**\n     * Returns the last unknown field by field number.\n     */\n    UnknownFieldHandler.last = (message, fieldNo) => UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];\n    const is = (message) => message && Array.isArray(message[UnknownFieldHandler.symbol]);\n})(UnknownFieldHandler || (UnknownFieldHandler = {}));\n/**\n * Make options for writing binary data form partial options.\n */\nexport function binaryWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;\n}\n/**\n * Make options for reading binary data form partial options.\n */\nexport function binaryReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;\n}\nconst defaultsRead = {\n    readUnknownField: true,\n    readerFactory: bytes => new BinaryReader(bytes),\n}, defaultsWrite = {\n    writeUnknownFields: true,\n    writerFactory: () => new BinaryWriter(),\n};\n/**\n * Merges binary write or read options. Later values override earlier values.\n */\nexport function mergeBinaryOptions(a, b) {\n    return Object.assign(Object.assign({}, a), b);\n}\n/**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */\nexport var WireType;\n(function (WireType) {\n    /**\n     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n     */\n    WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n     * Used for fixed64, sfixed64, double.\n     * Always 8 bytes.\n     */\n    WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n     * Used for string, bytes, embedded messages, packed repeated fields\n     *\n     * Only repeated numeric types (types which use the varint, 32-bit,\n     * or 64-bit wire types) can be packed. In proto3, such fields are\n     * packed by default.\n     */\n    WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n     * Used for groups\n     * @deprecated\n     */\n    WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n     * Used for groups\n     * @deprecated\n     */\n    WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n     * Used for fixed32, sfixed32, float.\n     * Always 4 bytes.\n     */\n    WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\n", "const defaultsWrite = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0,\n}, defaultsRead = {\n    ignoreUnknownFields: false,\n};\n/**\n * Make options for reading JSON data from partial options.\n */\nexport function jsonReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;\n}\n/**\n * Make options for writing JSON data from partial options.\n */\nexport function jsonWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;\n}\n/**\n * Merges JSON write or read options. Later values override earlier values. Type registries are merged.\n */\nexport function mergeJsonOptions(a, b) {\n    var _a, _b;\n    let c = Object.assign(Object.assign({}, a), b);\n    c.typeRegistry = [...((_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : []), ...((_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : [])];\n    return c;\n}\n", "/**\n * An error that occurred while calling a RPC method.\n */\nexport class RpcError extends Error {\n    constructor(message, code = 'UNKNOWN', meta) {\n        super(message);\n        this.name = 'RpcError';\n        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#example\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.code = code;\n        this.meta = meta !== null && meta !== void 0 ? meta : {};\n    }\n    toString() {\n        const l = [this.name + ': ' + this.message];\n        if (this.code) {\n            l.push('');\n            l.push('Code: ' + this.code);\n        }\n        let m = Object.entries(this.meta);\n        if (m.length) {\n            l.push('');\n            l.push('Meta:');\n            for (let [k, v] of m) {\n                l.push(`  ${k}: ${v}`);\n            }\n        }\n        return l.join('\\n');\n    }\n}\n", "import { mergeBinaryOptions, mergeJsonOptions } from \"@protobuf-ts/runtime\";\n/**\n * Merges custom RPC options with defaults. Returns a new instance and keeps\n * the \"defaults\" and the \"options\" unmodified.\n *\n * Merges `RpcMetadata` \"meta\", overwriting values from \"defaults\" with\n * values from \"options\". Does not append values to existing entries.\n *\n * Merges \"jsonOptions\", including \"jsonOptions.typeRegistry\", by creating\n * a new array that contains types from \"options.jsonOptions.typeRegistry\"\n * first, then types from \"defaults.jsonOptions.typeRegistry\".\n *\n * Merges \"binaryOptions\".\n *\n * Merges \"interceptors\" by creating a new array that contains interceptors\n * from \"defaults\" first, then interceptors from \"options\".\n *\n * Works with objects that extend `RpcOptions`, but only if the added\n * properties are of type Date, primitive like string, boolean, or Array\n * of primitives. If you have other property types, you have to merge them\n * yourself.\n */\nexport function mergeRpcOptions(defaults, options) {\n    if (!options)\n        return defaults;\n    let o = {};\n    copy(defaults, o);\n    copy(options, o);\n    for (let key of Object.keys(options)) {\n        let val = options[key];\n        switch (key) {\n            case \"jsonOptions\":\n                o.jsonOptions = mergeJsonOptions(defaults.jsonOptions, o.jsonOptions);\n                break;\n            case \"binaryOptions\":\n                o.binaryOptions = mergeBinaryOptions(defaults.binaryOptions, o.binaryOptions);\n                break;\n            case \"meta\":\n                o.meta = {};\n                copy(defaults.meta, o.meta);\n                copy(options.meta, o.meta);\n                break;\n            case \"interceptors\":\n                o.interceptors = defaults.interceptors ? defaults.interceptors.concat(val) : val.concat();\n                break;\n        }\n    }\n    return o;\n}\nfunction copy(a, into) {\n    if (!a)\n        return;\n    let c = into;\n    for (let [k, v] of Object.entries(a)) {\n        if (v instanceof Date)\n            c[k] = new Date(v.getTime());\n        else if (Array.isArray(v))\n            c[k] = v.concat();\n        else\n            c[k] = v;\n    }\n}\n", "export var DeferredState;\n(function (DeferredState) {\n    DeferredState[DeferredState[\"PENDING\"] = 0] = \"PENDING\";\n    DeferredState[DeferredState[\"REJECTED\"] = 1] = \"REJECTED\";\n    DeferredState[DeferredState[\"RESOLVED\"] = 2] = \"RESOLVED\";\n})(DeferredState || (DeferredState = {}));\n/**\n * A deferred promise. This is a \"controller\" for a promise, which lets you\n * pass a promise around and reject or resolve it from the outside.\n *\n * Warning: This class is to be used with care. Using it can make code very\n * difficult to read. It is intended for use in library code that exposes\n * promises, not for regular business logic.\n */\nexport class Deferred {\n    /**\n     * @param preventUnhandledRejectionWarning - prevents the warning\n     * \"Unhandled Promise rejection\" by adding a noop rejection handler.\n     * Working with calls returned from the runtime-rpc package in an\n     * async function usually means awaiting one call property after\n     * the other. This means that the \"status\" is not being awaited when\n     * an earlier await for the \"headers\" is rejected. This causes the\n     * \"unhandled promise reject\" warning. A more correct behaviour for\n     * calls might be to become aware whether at least one of the\n     * promises is handled and swallow the rejection warning for the\n     * others.\n     */\n    constructor(preventUnhandledRejectionWarning = true) {\n        this._state = DeferredState.PENDING;\n        this._promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        if (preventUnhandledRejectionWarning) {\n            this._promise.catch(_ => { });\n        }\n    }\n    /**\n     * Get the current state of the promise.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Get the deferred promise.\n     */\n    get promise() {\n        return this._promise;\n    }\n    /**\n     * Resolve the promise. Throws if the promise is already resolved or rejected.\n     */\n    resolve(value) {\n        if (this.state !== DeferredState.PENDING)\n            throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);\n        this._resolve(value);\n        this._state = DeferredState.RESOLVED;\n    }\n    /**\n     * Reject the promise. Throws if the promise is already resolved or rejected.\n     */\n    reject(reason) {\n        if (this.state !== DeferredState.PENDING)\n            throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);\n        this._reject(reason);\n        this._state = DeferredState.REJECTED;\n    }\n    /**\n     * Resolve the promise. Ignore if not pending.\n     */\n    resolvePending(val) {\n        if (this._state === DeferredState.PENDING)\n            this.resolve(val);\n    }\n    /**\n     * Reject the promise. Ignore if not pending.\n     */\n    rejectPending(reason) {\n        if (this._state === DeferredState.PENDING)\n            this.reject(reason);\n    }\n}\n", "import { Deferred, DeferredState } from \"./deferred\";\nimport { assert } from \"@protobuf-ts/runtime\";\n/**\n * A `RpcOutputStream` that you control.\n */\nexport class RpcOutputStreamController {\n    constructor() {\n        this._lis = {\n            nxt: [],\n            msg: [],\n            err: [],\n            cmp: [],\n        };\n        this._closed = false;\n    }\n    // --- RpcOutputStream callback API\n    onNext(callback) {\n        return this.addLis(callback, this._lis.nxt);\n    }\n    onMessage(callback) {\n        return this.addLis(callback, this._lis.msg);\n    }\n    onError(callback) {\n        return this.addLis(callback, this._lis.err);\n    }\n    onComplete(callback) {\n        return this.addLis(callback, this._lis.cmp);\n    }\n    addLis(callback, list) {\n        list.push(callback);\n        return () => {\n            let i = list.indexOf(callback);\n            if (i >= 0)\n                list.splice(i, 1);\n        };\n    }\n    // remove all listeners\n    clearLis() {\n        for (let l of Object.values(this._lis))\n            l.splice(0, l.length);\n    }\n    // --- Controller API\n    /**\n     * Is this stream already closed by a completion or error?\n     */\n    get closed() {\n        return this._closed !== false;\n    }\n    /**\n     * Emit message, close with error, or close successfully, but only one\n     * at a time.\n     * Can be used to wrap a stream by using the other stream's `onNext`.\n     */\n    notifyNext(message, error, complete) {\n        assert((message ? 1 : 0) + (error ? 1 : 0) + (complete ? 1 : 0) <= 1, 'only one emission at a time');\n        if (message)\n            this.notifyMessage(message);\n        if (error)\n            this.notifyError(error);\n        if (complete)\n            this.notifyComplete();\n    }\n    /**\n     * Emits a new message. Throws if stream is closed.\n     *\n     * Triggers onNext and onMessage callbacks.\n     */\n    notifyMessage(message) {\n        assert(!this.closed, 'stream is closed');\n        this.pushIt({ value: message, done: false });\n        this._lis.msg.forEach(l => l(message));\n        this._lis.nxt.forEach(l => l(message, undefined, false));\n    }\n    /**\n     * Closes the stream with an error. Throws if stream is closed.\n     *\n     * Triggers onNext and onError callbacks.\n     */\n    notifyError(error) {\n        assert(!this.closed, 'stream is closed');\n        this._closed = error;\n        this.pushIt(error);\n        this._lis.err.forEach(l => l(error));\n        this._lis.nxt.forEach(l => l(undefined, error, false));\n        this.clearLis();\n    }\n    /**\n     * Closes the stream successfully. Throws if stream is closed.\n     *\n     * Triggers onNext and onComplete callbacks.\n     */\n    notifyComplete() {\n        assert(!this.closed, 'stream is closed');\n        this._closed = true;\n        this.pushIt({ value: null, done: true });\n        this._lis.cmp.forEach(l => l());\n        this._lis.nxt.forEach(l => l(undefined, undefined, true));\n        this.clearLis();\n    }\n    /**\n     * Creates an async iterator (that can be used with `for await {...}`)\n     * to consume the stream.\n     *\n     * Some things to note:\n     * - If an error occurs, the `for await` will throw it.\n     * - If an error occurred before the `for await` was started, `for await`\n     *   will re-throw it.\n     * - If the stream is already complete, the `for await` will be empty.\n     * - If your `for await` consumes slower than the stream produces,\n     *   for example because you are relaying messages in a slow operation,\n     *   messages are queued.\n     */\n    [Symbol.asyncIterator]() {\n        // init the iterator state, enabling pushIt()\n        if (!this._itState) {\n            this._itState = { q: [] };\n        }\n        // if we are closed, we are definitely not receiving any more messages.\n        // but we can't let the iterator get stuck. we want to either:\n        // a) finish the new iterator immediately, because we are completed\n        // b) reject the new iterator, because we errored\n        if (this._closed === true)\n            this.pushIt({ value: null, done: true });\n        else if (this._closed !== false)\n            this.pushIt(this._closed);\n        // the async iterator\n        return {\n            next: () => {\n                let state = this._itState;\n                assert(state, \"bad state\"); // if we don't have a state here, code is broken\n                // there should be no pending result.\n                // did the consumer call next() before we resolved our previous result promise?\n                assert(!state.p, \"iterator contract broken\");\n                // did we produce faster than the iterator consumed?\n                // return the oldest result from the queue.\n                let first = state.q.shift();\n                if (first)\n                    return (\"value\" in first) ? Promise.resolve(first) : Promise.reject(first);\n                // we have no result ATM, but we promise one.\n                // as soon as we have a result, we must resolve promise.\n                state.p = new Deferred();\n                return state.p.promise;\n            },\n        };\n    }\n    // \"push\" a new iterator result.\n    // this either resolves a pending promise, or enqueues the result.\n    pushIt(result) {\n        let state = this._itState;\n        if (!state)\n            return;\n        // is the consumer waiting for us?\n        if (state.p) {\n            // yes, consumer is waiting for this promise.\n            const p = state.p;\n            assert(p.state == DeferredState.PENDING, \"iterator contract broken\");\n            // resolve the promise\n            (\"value\" in result) ? p.resolve(result) : p.reject(result);\n            // must cleanup, otherwise iterator.next() would pick it up again.\n            delete state.p;\n        }\n        else {\n            // we are producing faster than the iterator consumes.\n            // push result onto queue.\n            state.q.push(result);\n        }\n    }\n}\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * A unary RPC call. Unary means there is exactly one input message and\n * exactly one output message unless an error occurred.\n */\nexport class UnaryCall {\n    constructor(method, requestHeaders, request, headers, response, status, trailers) {\n        this.method = method;\n        this.requestHeaders = requestHeaders;\n        this.request = request;\n        this.headers = headers;\n        this.response = response;\n        this.status = status;\n        this.trailers = trailers;\n    }\n    /**\n     * If you are only interested in the final outcome of this call,\n     * you can await it to receive a `FinishedUnaryCall`.\n     */\n    then(onfulfilled, onrejected) {\n        return this.promiseFinished().then(value => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, reason => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));\n    }\n    promiseFinished() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);\n            return {\n                method: this.method,\n                requestHeaders: this.requestHeaders,\n                request: this.request,\n                headers,\n                response,\n                status,\n                trailers\n            };\n        });\n    }\n}\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * A server streaming RPC call. The client provides exactly one input message\n * but the server may respond with 0, 1, or more messages.\n */\nexport class ServerStreamingCall {\n    constructor(method, requestHeaders, request, headers, response, status, trailers) {\n        this.method = method;\n        this.requestHeaders = requestHeaders;\n        this.request = request;\n        this.headers = headers;\n        this.responses = response;\n        this.status = status;\n        this.trailers = trailers;\n    }\n    /**\n     * Instead of awaiting the response status and trailers, you can\n     * just as well await this call itself to receive the server outcome.\n     * You should first setup some listeners to the `request` to\n     * see the actual messages the server replied with.\n     */\n    then(onfulfilled, onrejected) {\n        return this.promiseFinished().then(value => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, reason => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));\n    }\n    promiseFinished() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);\n            return {\n                method: this.method,\n                requestHeaders: this.requestHeaders,\n                request: this.request,\n                headers,\n                status,\n                trailers,\n            };\n        });\n    }\n}\n", "// Copyright 2016 gRPC authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * See [grpc status_code_enum.h](https://github.com/grpc/grpc/blob/a19d8dcfb50caa81cddc25bc1a6afdd7a2f497b7/include/grpcpp/impl/codegen/status_code_enum.h#L24)\n *\n * Copyright 2020 Google LLC\n */\nexport var GrpcStatusCode;\n(function (GrpcStatusCode) {\n    /**\n     * Not an error; returned on success.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"OK\"] = 0] = \"OK\";\n    /**\n     * The operation was cancelled (typically by the caller).\n     */\n    GrpcStatusCode[GrpcStatusCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    /**\n     * Unknown error. An example of where this error may be returned is if a\n     * Status value received from another address space belongs to an error-space\n     * that is not known in this address space. Also errors raised by APIs that\n     * do not return enough error information may be converted to this error.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    /**\n     * Client specified an invalid argument. Note that this differs from\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n     * problematic regardless of the state of the system (e.g., a malformed file\n     * name).\n     */\n    GrpcStatusCode[GrpcStatusCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    /**\n     * Deadline expired before operation could complete. For operations that\n     * change the state of the system, this error may be returned even if the\n     * operation has completed successfully. For example, a successful response\n     * from a server could have been delayed long enough for the deadline to\n     * expire.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    /**\n     * Some requested entity (e.g., file or directory) was not found.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    /**\n     * Some entity that we attempted to create (e.g., file or directory) already\n     * exists.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    /**\n     * The caller does not have permission to execute the specified operation.\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\n     * PERMISSION_DENIED must not be used if the caller can not be identified\n     * (use UNAUTHENTICATED instead for those errors).\n     */\n    GrpcStatusCode[GrpcStatusCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    /**\n     * The request does not have valid authentication credentials for the\n     * operation.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n    /**\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n     * entire file system is out of space.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    /**\n     * Operation was rejected because the system is not in a state required for\n     * the operations execution. For example, directory to be deleted may be\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\n     *\n     * A litmus test that may help a service implementor in deciding\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\n     *  (b) Use ABORTED if the client should retry at a higher-level\n     *      (e.g., restarting a read-modify-write sequence).\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\n     *      should be returned since the client should not retry unless\n     *      they have first fixed up the directory by deleting files from it.\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\n     *      REST Get/Update/Delete on a resource and the resource on the\n     *      server does not match the condition. E.g., conflicting\n     *      read-modify-write on the same resource.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    /**\n     * The operation was aborted, typically due to a concurrency issue like\n     * sequencer check failures, transaction aborts, etc.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"ABORTED\"] = 10] = \"ABORTED\";\n    /**\n     * Operation was attempted past the valid range. E.g., seeking or reading\n     * past end of file.\n     *\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n     * if the system state changes. For example, a 32-bit file system will\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n     * an offset past the current file size.\n     *\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n     * when it applies so that callers who are iterating through a space can\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    /**\n     * Operation is not implemented or not supported/enabled in this service.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    /**\n     * Internal errors. Means some invariants expected by underlying System has\n     * been broken. If you see one of these errors, Something is very broken.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    /**\n     * The service is currently unavailable. This is a most likely a transient\n     * condition and may be corrected by retrying with a backoff.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    /**\n     * Unrecoverable data loss or corruption.\n     */\n    GrpcStatusCode[GrpcStatusCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n})(GrpcStatusCode || (GrpcStatusCode = {}));\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { base64decode, base64encode } from \"@protobuf-ts/runtime\";\nimport { RpcError } from \"@protobuf-ts/runtime-rpc\";\nimport { GrpcStatusCode } from \"./goog-grpc-status-code\";\n/**\n * Create fetch API headers for a grpc-web request.\n */\nexport function createGrpcWebRequestHeader(headers, format, timeout, meta, userAgent) {\n    // add meta as headers\n    if (meta) {\n        for (let [k, v] of Object.entries(meta)) {\n            if (typeof v == \"string\")\n                headers.append(k, v);\n            else\n                for (let i of v)\n                    headers.append(k, i);\n        }\n    }\n    // set standard headers (possibly overwriting meta)\n    headers.set('Content-Type', format === \"text\" ? \"application/grpc-web-text\" : \"application/grpc-web+proto\");\n    if (format == \"text\") {\n        // The client library should indicate to the server via the \"Accept\" header that\n        // the response stream needs to be text encoded e.g. when XHR is used or due to\n        // security policies with XHR\n        headers.set(\"Accept\", \"application/grpc-web-text\");\n    }\n    headers.set('X-Grpc-Web', \"1\");\n    if (userAgent)\n        headers.set(\"X-User-Agent\", userAgent);\n    if (typeof timeout === \"number\") {\n        if (timeout <= 0) {\n            // we raise an error ourselves because header \"grpc-timeout\" must be a positive integer\n            throw new RpcError(`timeout ${timeout} ms exceeded`, GrpcStatusCode[GrpcStatusCode.DEADLINE_EXCEEDED]);\n        }\n        headers.set('grpc-timeout', `${timeout}m`);\n    }\n    else if (timeout) {\n        const deadline = timeout.getTime();\n        const now = Date.now();\n        if (deadline <= now) {\n            // we raise an error ourselves because header \"grpc-timeout\" must be a positive integer\n            throw new RpcError(`deadline ${timeout} exceeded`, GrpcStatusCode[GrpcStatusCode.DEADLINE_EXCEEDED]);\n        }\n        headers.set('grpc-timeout', `${deadline - now}m`);\n    }\n    return headers;\n}\n/**\n * Create a fetch API request body for a grpc-web request.\n *\n * Packs the serialized message into a data frame, and base64 encodes if\n * format is \"text\".\n */\nexport function createGrpcWebRequestBody(message, format) {\n    let body = new Uint8Array(5 + message.length); // we need 5 bytes for frame type + message length\n    body[0] = GrpcWebFrame.DATA; // first byte is frame type\n    // 4 bytes message length\n    for (let msgLen = message.length, i = 4; i > 0; i--) {\n        body[i] = (msgLen % 256);\n        msgLen >>>= 8;\n    }\n    body.set(message, 5); // reset is message\n    return format === \"binary\" ? body : base64encode(body);\n}\nexport function readGrpcWebResponseHeader(headersOrFetchResponse, httpStatus, httpStatusText) {\n    if (arguments.length === 1) {\n        let fetchResponse = headersOrFetchResponse;\n        switch (fetchResponse.type) {\n            case \"error\":\n            case \"opaque\":\n            case \"opaqueredirect\":\n                // see https://developer.mozilla.org/en-US/docs/Web/API/Response/type\n                throw new RpcError(`fetch response type ${fetchResponse.type}`, GrpcStatusCode[GrpcStatusCode.UNKNOWN]);\n        }\n        return readGrpcWebResponseHeader(fetchHeadersToHttp(fetchResponse.headers), fetchResponse.status, fetchResponse.statusText);\n    }\n    let headers = headersOrFetchResponse, httpOk = httpStatus >= 200 && httpStatus < 300, responseMeta = parseMetadata(headers), [statusCode, statusDetail] = parseStatus(headers);\n    if (statusCode === GrpcStatusCode.OK && !httpOk) {\n        statusCode = httpStatusToGrpc(httpStatus);\n        statusDetail = httpStatusText;\n    }\n    return [statusCode, statusDetail, responseMeta];\n}\n/**\n * Parses a grpc status (code and optional text) and meta data from response\n * trailers.\n *\n * Response trailers are expected as a byte array, but are actually just an\n * ASCII string with HTTP headers. Just pass the data of a grpc-web trailer\n * frame.\n */\nexport function readGrpcWebResponseTrailer(data) {\n    let headers = parseTrailer(data), [code, detail] = parseStatus(headers), meta = parseMetadata(headers);\n    return [code, detail, meta];\n}\n/**\n * A grpc-frame type. Can be used to determine type of frame emitted by\n * `readGrpcWebResponseBody()`.\n */\nexport var GrpcWebFrame;\n(function (GrpcWebFrame) {\n    GrpcWebFrame[GrpcWebFrame[\"DATA\"] = 0] = \"DATA\";\n    GrpcWebFrame[GrpcWebFrame[\"TRAILER\"] = 128] = \"TRAILER\";\n})(GrpcWebFrame || (GrpcWebFrame = {}));\n/**\n * Parses a grpc-web response (unary or server streaming) from a fetch API\n * stream.\n *\n * Emits grpc-web frames.\n *\n * The returned promise resolves when the response is complete.\n */\nexport function readGrpcWebResponseBody(stream, contentType, onFrame) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let streamReader, base64queue = \"\", byteQueue = new Uint8Array(0), format = parseFormat(contentType);\n        // allows to read streams from the 'node-fetch' polyfill which uses\n        // node.js ReadableStream instead of the what-wg streams api ReadableStream\n        if (typeof stream.getReader == 'function') {\n            let whatWgReadableStream = stream.getReader();\n            streamReader = {\n                next: () => whatWgReadableStream.read()\n            };\n        }\n        else {\n            streamReader = stream[Symbol.asyncIterator]();\n        }\n        while (true) {\n            let result = yield streamReader.next();\n            if (result.value !== undefined) {\n                if (format === \"text\") {\n                    // the statements below just decode base64 and append to `bytesUnread`\n                    // add incoming base64 to queue\n                    for (let i = 0; i < result.value.length; i++)\n                        base64queue += String.fromCharCode(result.value[i]);\n                    // if the base64 queue is not a multiple of 4,\n                    // we have to wait for more data\n                    let safeLen = base64queue.length - base64queue.length % 4;\n                    if (safeLen === 0)\n                        continue;\n                    // decode safe chunk of base64 and add to byte queue\n                    byteQueue = concatBytes(byteQueue, base64decode(base64queue.substring(0, safeLen)));\n                    base64queue = base64queue.substring(safeLen);\n                }\n                else {\n                    byteQueue = concatBytes(byteQueue, result.value);\n                }\n                // read all fully available data frames\n                while (byteQueue.length >= 5 && byteQueue[0] === GrpcWebFrame.DATA) {\n                    let msgLen = 0;\n                    for (let i = 1; i < 5; i++)\n                        msgLen = (msgLen << 8) + byteQueue[i];\n                    if (byteQueue.length - 5 >= msgLen) {\n                        // we have the entire message\n                        onFrame(GrpcWebFrame.DATA, byteQueue.subarray(5, 5 + msgLen));\n                        byteQueue = byteQueue.subarray(5 + msgLen);\n                    }\n                    else\n                        break; //  wait for more data\n                }\n            }\n            // exit, but emit trailer if exists\n            if (result.done) {\n                if (byteQueue.length === 0)\n                    break;\n                if (byteQueue[0] !== GrpcWebFrame.TRAILER || byteQueue.length < 5)\n                    throw new RpcError(\"premature EOF\", GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);\n                onFrame(GrpcWebFrame.TRAILER, byteQueue.subarray(5));\n                break;\n            }\n        }\n    });\n}\n// internal\nfunction concatBytes(a, b) {\n    let n = new Uint8Array(a.length + b.length);\n    n.set(a);\n    n.set(b, a.length);\n    return n;\n}\n// determines format from response \"content-type\" value.\n// throws if value is unknown or missing.\nfunction parseFormat(contentType) {\n    // > the sender *should* always specify the message format, e.g. +proto, +json\n    //\n    // > the receiver should assume the default is \"+proto\" when the message format is\n    // > missing in Content-Type (as \"application/grpc-web\")\n    //\n    // see https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md\n    switch (contentType) {\n        case \"application/grpc-web-text\":\n        case \"application/grpc-web-text+proto\":\n            return \"text\";\n        case \"application/grpc-web\":\n        case \"application/grpc-web+proto\":\n            return \"binary\";\n        case undefined:\n        case null:\n            throw new RpcError(\"missing response content type\", GrpcStatusCode[GrpcStatusCode.INTERNAL]);\n        default:\n            throw new RpcError(\"unexpected response content type: \" + contentType, GrpcStatusCode[GrpcStatusCode.INTERNAL]);\n    }\n}\n// returns error code on parse failure, uses OK as default code\nfunction parseStatus(headers) {\n    let code = GrpcStatusCode.OK, message;\n    let m = headers['grpc-message'];\n    if (m !== undefined) {\n        if (Array.isArray(m))\n            return [GrpcStatusCode.INTERNAL, \"invalid grpc-web message\"];\n        message = m;\n    }\n    let s = headers['grpc-status'];\n    if (s !== undefined) {\n        if (Array.isArray(m) || GrpcStatusCode[code] === undefined)\n            return [GrpcStatusCode.INTERNAL, \"invalid grpc-web status\"];\n        code = parseInt(s);\n    }\n    return [code, message];\n}\n// skips grpc-web headers\nfunction parseMetadata(headers) {\n    let meta = {};\n    for (let [k, v] of Object.entries(headers))\n        switch (k) {\n            case 'grpc-message':\n            case 'grpc-status':\n            case 'content-type':\n                break;\n            default:\n                meta[k] = v;\n        }\n    return meta;\n}\n// parse trailer data (ASCII) to our headers rep\nfunction parseTrailer(trailerData) {\n    let headers = {};\n    for (let chunk of String.fromCharCode.apply(String, trailerData).trim().split(\"\\r\\n\")) {\n        let [key, value] = chunk.split(\":\", 2);\n        key = key.trim();\n        value = value.trim();\n        let e = headers[key];\n        if (typeof e == \"string\")\n            headers[key] = [e, value];\n        else if (Array.isArray(e))\n            e.push(value);\n        else\n            headers[key] = value;\n    }\n    return headers;\n}\n// fetch API to our headers rep\nfunction fetchHeadersToHttp(fetchHeaders) {\n    let headers = {};\n    fetchHeaders.forEach((value, key) => {\n        let e = headers[key];\n        if (typeof e == \"string\")\n            headers[key] = [e, value];\n        else if (Array.isArray(e))\n            e.push(value);\n        else\n            headers[key] = value;\n    });\n    return headers;\n}\n// internal\nfunction httpStatusToGrpc(httpStatus) {\n    switch (httpStatus) {\n        case 200:\n            return GrpcStatusCode.OK;\n        case 400:\n            return GrpcStatusCode.INVALID_ARGUMENT;\n        case 401:\n            return GrpcStatusCode.UNAUTHENTICATED;\n        case 403:\n            return GrpcStatusCode.PERMISSION_DENIED;\n        case 404:\n            return GrpcStatusCode.NOT_FOUND;\n        case 409:\n            return GrpcStatusCode.ABORTED;\n        case 412:\n            return GrpcStatusCode.FAILED_PRECONDITION;\n        case 429:\n            return GrpcStatusCode.RESOURCE_EXHAUSTED;\n        case 499:\n            return GrpcStatusCode.CANCELLED;\n        case 500:\n            return GrpcStatusCode.UNKNOWN;\n        case 501:\n            return GrpcStatusCode.UNIMPLEMENTED;\n        case 503:\n            return GrpcStatusCode.UNAVAILABLE;\n        case 504:\n            return GrpcStatusCode.DEADLINE_EXCEEDED;\n        default:\n            return GrpcStatusCode.UNKNOWN;\n    }\n}\n", "import { createGrpcWebRequestBody, createGrpcWebRequestHeader, GrpcWebFrame, readGrpcWebResponseBody, readGrpcWebResponseHeader, readGrpcWebResponseTrailer } from \"./grpc-web-format\";\nimport { Deferred, DeferredState, mergeRpcOptions, RpcError, RpcOutputStreamController, ServerStreamingCall, UnaryCall } from \"@protobuf-ts/runtime-rpc\";\nimport { GrpcStatusCode } from \"./goog-grpc-status-code\";\n/**\n * Implements the grpc-web protocol, supporting text format or binary\n * format on the wire. Uses the fetch API to do the HTTP requests.\n *\n * Does not support client streaming or duplex calls because grpc-web\n * does not support them.\n */\nexport class GrpcWebFetchTransport {\n    constructor(defaultOptions) {\n        this.defaultOptions = defaultOptions;\n    }\n    mergeOptions(options) {\n        return mergeRpcOptions(this.defaultOptions, options);\n    }\n    /**\n     * Create an URI for a gRPC web call.\n     *\n     * Takes the `baseUrl` option and appends:\n     * - slash \"/\"\n     * - package name\n     * - dot \".\"\n     * - service name\n     * - slash \"/\"\n     * - method name\n     *\n     * If the service was declared without a package, the package name and dot\n     * are omitted.\n     *\n     * All names are used exactly like declared in .proto.\n     */\n    makeUrl(method, options) {\n        let base = options.baseUrl;\n        if (base.endsWith('/'))\n            base = base.substring(0, base.length - 1);\n        return `${base}/${method.service.typeName}/${method.name}`;\n    }\n    clientStreaming( /*method: MethodInfo<I, O>, options: RpcOptions*/) {\n        throw new RpcError('Client streaming is not supported by grpc-web', GrpcStatusCode[GrpcStatusCode.UNIMPLEMENTED]);\n    }\n    duplex( /*method: MethodInfo<I, O>, options: RpcOptions*/) {\n        throw new RpcError('Duplex streaming is not supported by grpc-web', GrpcStatusCode[GrpcStatusCode.UNIMPLEMENTED]);\n    }\n    serverStreaming(method, input, options) {\n        var _a, _b, _c, _d;\n        let opt = options, format = (_a = opt.format) !== null && _a !== void 0 ? _a : 'text', fetchInit = (_b = opt.fetchInit) !== null && _b !== void 0 ? _b : {}, url = this.makeUrl(method, opt), inputBytes = method.I.toBinary(input, opt.binaryOptions), defHeader = new Deferred(), responseStream = new RpcOutputStreamController(), maybeStatus, defStatus = new Deferred(), maybeTrailer, defTrailer = new Deferred();\n        globalThis.fetch(url, Object.assign(Object.assign({}, fetchInit), { method: 'POST', headers: createGrpcWebRequestHeader(new globalThis.Headers(), format, opt.timeout, opt.meta), body: createGrpcWebRequestBody(inputBytes, format), signal: (_c = options.abort) !== null && _c !== void 0 ? _c : null // node-fetch@3.0.0-beta.9 rejects `undefined`\n         }))\n            .then(fetchResponse => {\n            let [code, detail, meta] = readGrpcWebResponseHeader(fetchResponse);\n            defHeader.resolve(meta);\n            if (code !== GrpcStatusCode.OK)\n                throw new RpcError(detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code], GrpcStatusCode[code], meta);\n            return fetchResponse;\n        })\n            .then(fetchResponse => {\n            if (!fetchResponse.body)\n                throw new RpcError('missing response body', GrpcStatusCode[GrpcStatusCode.INTERNAL]);\n            return readGrpcWebResponseBody(fetchResponse.body, fetchResponse.headers.get('content-type'), (type, data) => {\n                switch (type) {\n                    case GrpcWebFrame.DATA:\n                        responseStream.notifyMessage(method.O.fromBinary(data, opt.binaryOptions));\n                        break;\n                    case GrpcWebFrame.TRAILER:\n                        let code, detail;\n                        [code, detail, maybeTrailer] = readGrpcWebResponseTrailer(data);\n                        maybeStatus = {\n                            code: GrpcStatusCode[code],\n                            detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code]\n                        };\n                        break;\n                }\n            });\n        })\n            .then(() => {\n            if (!maybeTrailer)\n                throw new RpcError(`missing trailers`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);\n            if (!maybeStatus)\n                throw new RpcError(`missing status`, GrpcStatusCode[GrpcStatusCode.INTERNAL]);\n            if (maybeStatus.code !== 'OK')\n                throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);\n            responseStream.notifyComplete();\n            defStatus.resolve(maybeStatus);\n            defTrailer.resolve(maybeTrailer);\n        })\n            .catch(reason => {\n            let error;\n            if (reason instanceof RpcError)\n                error = reason;\n            else if (reason instanceof Error && reason.name === 'AbortError')\n                // aborted\n                error = new RpcError(reason.message, GrpcStatusCode[GrpcStatusCode.CANCELLED]);\n            else\n                // RpcErrors are thrown by us, everything else is an internal error\n                error = new RpcError(reason instanceof Error ? reason.message : \"\" + reason, GrpcStatusCode[GrpcStatusCode.INTERNAL]);\n            defHeader.rejectPending(error);\n            responseStream.notifyError(error);\n            defStatus.rejectPending(error);\n            defTrailer.rejectPending(error);\n        });\n        return new ServerStreamingCall(method, (_d = opt.meta) !== null && _d !== void 0 ? _d : {}, input, defHeader.promise, responseStream, defStatus.promise, defTrailer.promise);\n    }\n    unary(method, input, options) {\n        var _a, _b, _c, _d;\n        let opt = options, format = (_a = opt.format) !== null && _a !== void 0 ? _a : 'text', fetchInit = (_b = opt.fetchInit) !== null && _b !== void 0 ? _b : {}, url = this.makeUrl(method, opt), inputBytes = method.I.toBinary(input, opt.binaryOptions), defHeader = new Deferred(), maybeMessage, defMessage = new Deferred(), maybeStatus, defStatus = new Deferred(), maybeTrailer, defTrailer = new Deferred();\n        globalThis.fetch(url, Object.assign(Object.assign({}, fetchInit), { method: 'POST', headers: createGrpcWebRequestHeader(new globalThis.Headers(), format, opt.timeout, opt.meta), body: createGrpcWebRequestBody(inputBytes, format), signal: (_c = options.abort) !== null && _c !== void 0 ? _c : null // node-fetch@3.0.0-beta.9 rejects `undefined`\n         }))\n            .then(fetchResponse => {\n            let [code, detail, meta] = readGrpcWebResponseHeader(fetchResponse);\n            defHeader.resolve(meta);\n            if (code !== GrpcStatusCode.OK)\n                throw new RpcError(detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code], GrpcStatusCode[code], meta);\n            return fetchResponse;\n        })\n            .then(fetchResponse => {\n            if (!fetchResponse.body)\n                throw new RpcError('missing response body', GrpcStatusCode[GrpcStatusCode.INTERNAL]);\n            return readGrpcWebResponseBody(fetchResponse.body, fetchResponse.headers.get('content-type'), (type, data) => {\n                switch (type) {\n                    case GrpcWebFrame.DATA:\n                        if (defMessage.state === DeferredState.RESOLVED)\n                            throw new RpcError(`unary call received 2nd message`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);\n                        maybeMessage = method.O.fromBinary(data, opt.binaryOptions);\n                        break;\n                    case GrpcWebFrame.TRAILER:\n                        let code, detail;\n                        [code, detail, maybeTrailer] = readGrpcWebResponseTrailer(data);\n                        maybeStatus = {\n                            code: GrpcStatusCode[code],\n                            detail: detail !== null && detail !== void 0 ? detail : GrpcStatusCode[code]\n                        };\n                        break;\n                }\n            });\n        })\n            .then(() => {\n            if (!maybeTrailer)\n                throw new RpcError(`missing trailers`, GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);\n            if (!maybeStatus)\n                throw new RpcError(`missing status`, GrpcStatusCode[GrpcStatusCode.INTERNAL]);\n            if (!maybeMessage && maybeStatus.code === 'OK')\n                throw new RpcError('expected error status', GrpcStatusCode[GrpcStatusCode.DATA_LOSS]);\n            if (!maybeMessage)\n                throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);\n            defMessage.resolve(maybeMessage);\n            if (maybeStatus.code !== 'OK')\n                throw new RpcError(maybeStatus.detail, maybeStatus.code, maybeTrailer);\n            defStatus.resolve(maybeStatus);\n            defTrailer.resolve(maybeTrailer);\n        })\n            .catch(reason => {\n            let error;\n            if (reason instanceof RpcError)\n                error = reason;\n            else if (reason instanceof Error && reason.name === 'AbortError')\n                // aborted\n                error = new RpcError(reason.message, GrpcStatusCode[GrpcStatusCode.CANCELLED]);\n            else\n                // RpcErrors are thrown by us, everything else is an internal error\n                error = new RpcError(reason instanceof Error ? reason.message : \"\" + reason, GrpcStatusCode[GrpcStatusCode.INTERNAL]);\n            defHeader.rejectPending(error);\n            defMessage.rejectPending(error);\n            defStatus.rejectPending(error);\n            defTrailer.rejectPending(error);\n        });\n        return new UnaryCall(method, (_d = opt.meta) !== null && _d !== void 0 ? _d : {}, input, defHeader.promise, defMessage.promise, defStatus.promise, defTrailer.promise);\n    }\n}\n", "import { BinaryReadOptions, BinaryWriteOptions, FieldInfo, IBinaryReader, IBinaryWriter, IMessageType, JsonReadOptions, JsonValue, JsonWriteOptions, JsonWriteStringOptions, PartialMessage } from \"@protobuf-ts/runtime\";\r\n\r\nexport interface UnityProtoMessage {\r\n  bytes: Uint8Array;\r\n}\r\n\r\nclass UnityProtoMessageType implements IMessageType<UnityProtoMessage> {\r\n    typeName: string = \"UnityMessage\";\r\n    fields: readonly FieldInfo[] = [];\r\n    options: { [extensionName: string]: JsonValue; } = {};\r\n  \r\n    create(value?: PartialMessage<UnityProtoMessage>): UnityProtoMessage {\r\n      if (!value) return { bytes: new Uint8Array(0) };\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n    fromBinary(data: Uint8Array, _options?: Partial<BinaryReadOptions>): UnityProtoMessage {\r\n      return { bytes: new Uint8Array(data) };\r\n    }\r\n    toBinary(message: UnityProtoMessage, _options?: Partial<BinaryWriteOptions>): Uint8Array {\r\n      return new Uint8Array(message.bytes);\r\n    }\r\n    fromJson(_json: JsonValue, _options?: Partial<JsonReadOptions>): UnityProtoMessage {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n    fromJsonString(_json: string, _options?: Partial<JsonReadOptions>): UnityProtoMessage {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n    toJson(_message: UnityProtoMessage, _options?: Partial<JsonWriteOptions>): JsonValue {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n    toJsonString(_message: UnityProtoMessage, _options?: Partial<JsonWriteStringOptions>): string {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n    clone(message: UnityProtoMessage): UnityProtoMessage {\r\n      return { bytes: new Uint8Array(message.bytes) };\r\n    }\r\n    mergePartial(_target: UnityProtoMessage, _source: PartialMessage<UnityProtoMessage>): void {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n    equals(a: UnityProtoMessage | undefined, b: UnityProtoMessage | undefined): boolean {\r\n      return Boolean(a?.bytes.length === b?.bytes.length && a?.bytes.every((v, i) => v === b?.bytes[i]));\r\n    }\r\n    is(_arg: any, _depth?: number): _arg is UnityProtoMessage {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n    isAssignable(_arg: any, _depth?: number): _arg is UnityProtoMessage {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n    internalJsonRead(_json: JsonValue, _options: JsonReadOptions, _target?: UnityProtoMessage): UnityProtoMessage {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n    internalJsonWrite(_message: UnityProtoMessage, _options: JsonWriteOptions): JsonValue {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n    internalBinaryWrite(_message: UnityProtoMessage, _writer: IBinaryWriter, _options: BinaryWriteOptions): IBinaryWriter {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n    internalBinaryRead(_reader: IBinaryReader, _length: number, _options: BinaryReadOptions, _target?: UnityProtoMessage): UnityProtoMessage {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n  }\r\n  \r\n  export const UnityProtoMessage = new UnityProtoMessageType();\r\n  ", "import { encode, decode } from \"base64-arraybuffer\";\r\nimport { RpcMetadata } from \"@protobuf-ts/runtime-rpc/build/types/rpc-metadata\";\r\n\r\nvar utf8Encoder = new TextEncoder();\r\nvar utf8Decoder = new TextDecoder();\r\nexport function toBase64(str: string): string {\r\n  var bytes = utf8Encoder.encode(str);\r\n  return encode(bytes.buffer);\r\n}\r\nexport function fromBase64(str: string): string {\r\n  var bytes = decode(str);\r\n  return utf8Decoder.decode(bytes);\r\n}\r\n\r\nexport const BinarySuffix = \"-bin\";\r\nexport function EncodeMetadata(metadata?: RpcMetadata): string {\r\n  if (!metadata) return \"\";\r\n  var entries = Object.entries(metadata);\r\n  if (entries.length == 0) return \"\";\r\n  var builder = \"\";\r\n  for (var entry of entries) {\r\n    var key = entry[0];\r\n    var values: string[];\r\n    if (Array.isArray(entry[1])) values = entry[1];\r\n    else values = [entry[1]];\r\n    for (var value of values) {\r\n\r\n      builder += toBase64(key);\r\n      builder += '|';\r\n      if (key.endsWith(BinarySuffix)) builder += value;\r\n      else builder += toBase64(value);\r\n    }\r\n  }\r\n  return builder;\r\n}\r\nexport function DecodeMetadata(str?: string): RpcMetadata | undefined {\r\n  if (!str) return undefined;\r\n  var lines = splitLines(str);\r\n  var metadata: RpcMetadata = {};\r\n  for (var line of lines) {\r\n    var [key, value] = line.split(\"|\");\r\n    key = fromBase64(key);\r\n    if(!key.endsWith(BinarySuffix)) value = fromBase64(value);\r\n\r\n    var existing = metadata[key];\r\n    if(Array.isArray(existing)) existing.push(value);\r\n    else if(typeof existing == \"string\") metadata[key] = [existing, value]\r\n    else metadata[key] = value;\r\n  }\r\n\r\n  return metadata;\r\n}\r\n\r\nconst splitLines = function (str: string) {\r\n  return str.split(/\\r?\\n/);\r\n}", "import { RpcCallShared } from \"@protobuf-ts/runtime-rpc/build/types/rpc-call-shared\";\r\nimport { UnityProtoMessage } from \"./UnityProtoMessage\";\r\nimport { Channel } from \"./Channel\";\r\n\r\n\r\nexport class Call {\r\n  readonly channel: Channel;\r\n  readonly callobj: RpcCallShared<UnityProtoMessage, UnityProtoMessage>;\r\n  readonly aborter: AbortController;\r\n\r\n  constructor(channel: Channel, aborter: AbortController, callobj: RpcCallShared<UnityProtoMessage, UnityProtoMessage>) {\r\n    this.callobj = callobj;\r\n    this.channel = channel;\r\n    this.aborter = aborter;\r\n  }\r\n\r\n  cancel() { this.aborter.abort(); }\r\n}\r\n", "import { encode, decode } from \"base64-arraybuffer\";\r\nimport { GrpcStatusCode, GrpcWebFetchTransport } from \"@protobuf-ts/grpcweb-transport\";\r\nimport { Instance } from \"./Instance\";\r\nimport { UnityProtoMessage } from \"./UnityProtoMessage\";\r\nimport { MethodInfo, RpcError, RpcOptions, RpcMetadata, RpcStatus } from \"@protobuf-ts/runtime-rpc\";\r\nimport { DecodeMetadata, EncodeMetadata, toBase64 } from \"./Utils\";\r\nimport { Call } from \"./Call\";\r\n\r\n\r\n\r\ntype GrpcCodeString = keyof typeof GrpcStatusCode;\r\n\r\nfunction CodeNum(str: String) {\r\n  return GrpcStatusCode[<GrpcCodeString>str];\r\n}\r\n\r\nexport class Channel {\r\n  static callCounter: number = 0;\r\n\r\n  channelKey: number;\r\n  transport: GrpcWebFetchTransport;\r\n  instance: Instance;\r\n\r\n  callMap = new Map<number, Call>();\r\n\r\n  constructor(channelKey: number, address: string, instance: Instance) {\r\n    this.channelKey = channelKey;\r\n    this.transport = new GrpcWebFetchTransport({ baseUrl: address });\r\n    this.instance = instance;\r\n  }\r\n\r\n  private reportFinishedCall(callKey: number, status: RpcStatus, trailers: RpcMetadata, message?: UnityProtoMessage) {\r\n    let params = [\r\n      this.channelKey,\r\n      callKey,\r\n      CodeNum(status.code),\r\n      toBase64(status.detail),\r\n      toBase64(EncodeMetadata(trailers))\r\n    ];\r\n    if(message) params.push(encode(message.bytes.buffer))\r\n    \r\n    this.instance.unityCaller.OnCallCompletion(\r\n      params.join(\"|\")\r\n    )\r\n  }\r\n\r\n  unaryRequest(serviceName: string, methodName: string, headers: string, base64Message: string, deadlineTimestampSecs: number): number {\r\n    const requestMethod = makeUnityMethodInfo(serviceName, methodName, GrpcRequestType.Unary);\r\n    const request = UnityProtoMessage.fromBinary(new Uint8Array(decode(base64Message)));\r\n    const aborter = new AbortController();\r\n    let options: RpcOptions = {\r\n      abort: aborter.signal,\r\n      meta: DecodeMetadata(headers),\r\n      timeout: deadlineTimestampSecs ? new Date(deadlineTimestampSecs * 1000) : undefined\r\n    };\r\n    options = this.transport.mergeOptions(options);\r\n    const call = this.transport.unary(requestMethod, request, options);\r\n\r\n    const callObj = new Call(this, aborter, call);\r\n    const callKey = Channel.callCounter++;\r\n    this.callMap.set(callKey, callObj);\r\n\r\n    call.headers.then(it => this.instance.unityCaller.OnHeaders(\r\n      [this.channelKey, \"|\", callKey, \"\\n\", EncodeMetadata(it)].join(\"\")\r\n    ))\r\n\r\n    call.then(\r\n      it => this.reportFinishedCall(callKey, it.status, it.trailers,it.response),\r\n      it => it instanceof RpcError ?\r\n        this.reportFinishedCall(callKey, {code: it.code, detail:it.message}, it.meta) :\r\n        this.reportFinishedCall(callKey, {code: GrpcStatusCode[GrpcStatusCode.INTERNAL], detail:\"Internal error in Channel.ts\" + it.message}, it.meta)\r\n      );\r\n\r\n    return callKey;\r\n  }\r\n\r\n\r\n\r\n  serverStreamRequest(serviceName: string, methodName: string, headers: string, base64Message: string, deadlineTimestampSecs: number): number {\r\n    const requestMethod = makeUnityMethodInfo(serviceName, methodName, GrpcRequestType.ServerStreaming);\r\n    const request = UnityProtoMessage.fromBinary(new Uint8Array(decode(base64Message)));\r\n    const aborter = new AbortController();\r\n    let options: RpcOptions = {\r\n      abort: aborter.signal,\r\n      meta: DecodeMetadata(headers),\r\n      timeout: deadlineTimestampSecs ? new Date(deadlineTimestampSecs * 1000) : undefined\r\n    };\r\n    options = this.transport.mergeOptions(options);\r\n    const call = this.transport.serverStreaming(requestMethod, request, options);\r\n    const callObj = new Call(this, aborter, call);\r\n    const callKey = Channel.callCounter++;\r\n    this.callMap.set(callKey, callObj);\r\n\r\n    call.headers.then(it => this.instance.unityCaller.OnHeaders(\r\n      [this.channelKey, \"|\", callKey, \"\\n\", EncodeMetadata(it)].join(\"\")\r\n    ))\r\n\r\n    call.responses.onMessage((message) => {\r\n      const encodedMessage = encode(message.bytes.buffer);\r\n      this.instance.unityCaller.OnServerStreamingResponse(\r\n        [this.channelKey, callKey, encodedMessage].join(\"|\"));\r\n      return;\r\n    });\r\n\r\n    call.then(\r\n      it => this.reportFinishedCall(callKey, it.status, it.trailers),\r\n      it => it instanceof RpcError ?\r\n        this.reportFinishedCall(callKey, {code: it.code, detail:it.message}, it.meta) :\r\n        this.reportFinishedCall(callKey, {code: GrpcStatusCode[GrpcStatusCode.INTERNAL], detail:\"Internal error in Channel.ts\" + it.message}, it.meta)\r\n      );\r\n    return callKey;\r\n  }\r\n\r\n  cancelRequest(callKey: number) {\r\n    const call = this.findCall(callKey);\r\n    call.cancel();\r\n  }\r\n\r\n  findCall(callKey: number): Call {\r\n    const call = this.callMap.get(callKey);\r\n    if (!call)\r\n      throw new Error(`Invalid callKey: ${callKey}`);\r\n    return call;\r\n  }\r\n}\r\n\r\nexport enum GrpcRequestType {\r\n  Unary = 0,\r\n  ServerStreaming = 1,\r\n  ClientStreaming = 2,\r\n  Duplex = 3,\r\n}\r\n\r\nexport function makeUnityMethodInfo(serviceName: string, methodName: string, requestType: GrpcRequestType):\r\n  MethodInfo<UnityProtoMessage, UnityProtoMessage> {\r\n\r\n  function lastElement<T>(arr: Array<T>) {\r\n    return arr.length ? arr[arr.length - 1] : null;\r\n  }\r\n\r\n  return {\r\n    service: {\r\n      methods: [],\r\n      options: {},\r\n      typeName: serviceName,\r\n    },\r\n    name: methodName,\r\n    localName: lastElement(methodName.split(\".\"))!,\r\n    idempotency: undefined,\r\n    serverStreaming: [GrpcRequestType.ServerStreaming, GrpcRequestType.Duplex].includes(requestType),\r\n    clientStreaming: [GrpcRequestType.ClientStreaming, GrpcRequestType.Duplex].includes(requestType),\r\n    options: {},\r\n    I: UnityProtoMessage,\r\n    O: UnityProtoMessage,\r\n  };\r\n}\r\n\r\n", "import { Channel } from \"./Channel\";\r\nimport { Connector } from \"./Connector\";\r\n\r\nexport class Instance {\r\n  readonly unityCaller: Connector;\r\n  readonly instanceKey: number;\r\n  readonly channelMap = new Map<number, Channel>();\r\n\r\n  private static channelCounter: number = 0;\r\n\r\n  constructor(unityCaller: Connector, instanceKey: number) {\r\n    this.unityCaller = unityCaller;\r\n    this.instanceKey = instanceKey;\r\n  }\r\n\r\n  makeChannel(address: string): number {\r\n    const channelKey = Instance.channelCounter++;\r\n    const channel = new Channel(channelKey, address, this);\r\n    this.channelMap.set(channelKey, channel);\r\n    return channelKey;\r\n  }\r\n\r\n  findChannel(channelKey: number): Channel {\r\n    const channel = this.channelMap.get(channelKey);\r\n    if (!channel)\r\n      throw new Error(`Invalid channelKey: ${channelKey}`);\r\n    return channel;\r\n  }\r\n}\r\n\r\n", "import { Connector } from \"./Connector\";\r\nimport { Instance } from \"./Instance\";\r\n\r\n\r\n\r\nexport default class Delegator {\r\n  private static instanceCounter: number = 0;\r\n  private instanceMap = new Map<number, Instance>();\r\n\r\n  findInstance(instanceKey: number): Instance {\r\n    const instance = this.instanceMap.get(instanceKey);\r\n    if (!instance) throw new Error(`Invalid instanceKey: ${instanceKey}`);\r\n    return instance;\r\n  }\r\n\r\n\r\n  RegisterInstance(unityCaller: UnityPlayer, objectName: string) {\r\n    const handler: ProxyHandler<Connector> = {\r\n      get(target, propName, _receiver) {\r\n        if (propName == \"Module\") return target.Module;\r\n        return function (param?: string | number) {\r\n          target.Module.SendMessage(objectName, propName.toString(), param);\r\n        }\r\n      }\r\n    }\r\n\r\n    const connector = new Proxy(<Connector>{ Module: unityCaller }, handler);\r\n\r\n    Delegator.instanceCounter++;\r\n    const instance = new Instance(connector, Delegator.instanceCounter);\r\n    this.instanceMap.set(instance.instanceKey, instance);\r\n    connector.OnInstanceRegistered(instance.instanceKey);\r\n  }\r\n\r\n  RegisterChannel(instanceKey: number, address: string): number {\r\n    const instance = this.findInstance(instanceKey);\r\n    return instance.makeChannel(address);\r\n  }\r\n\r\n  UnaryRequest(\r\n    instanceKey: number,\r\n    channelKey: number,\r\n    serviceName: string,\r\n    methodName: string,\r\n    headers:string,\r\n    base64Message:string,\r\n    deadlineTimestampSecs:number,\r\n  ): number {\r\n    const instance = this.findInstance(instanceKey);\r\n    const channel = instance.findChannel(channelKey);\r\n    return channel.unaryRequest(serviceName, methodName, headers, base64Message, deadlineTimestampSecs);\r\n  }\r\n\r\n  ServerStreamingRequest(\r\n    instanceKey: number,\r\n    channelKey: number,\r\n    serviceName: string,\r\n    methodName: string,\r\n    headers:string,\r\n    base64Message:string,\r\n    deadlineTimestampSecs:number\r\n  ): number {\r\n    const instance = this.findInstance(instanceKey);\r\n    const channel = instance.findChannel(channelKey);\r\n    return channel.serverStreamRequest(serviceName, methodName, headers, base64Message, deadlineTimestampSecs);\r\n  }\r\n  \r\n  CancelCall(\r\n    instanceKey: number,\r\n    channelKey: number,\r\n    callKey: number\r\n  ){\r\n    const instance = this.findInstance(instanceKey);\r\n    const channel = instance.findChannel(channelKey);\r\n    const call = channel.findCall(callKey);\r\n    call.cancel();\r\n  }\r\n\r\n}\r\n\r\n", "import Delegator from \"./GrpcWebConnector/Delegator\";\r\n// import TestService from \"./service\";\r\n\r\n// const service = new TestService(`http://${window.location.hostname}:${8001}`);\r\n\r\n// service.unary(\"HELLO\");\r\n// service.serverStream(\"HELLO\");\r\n\r\n\r\n(<any>window).GrpcWebUnityDelegator = new Delegator();\r\n"],
  "mappings": "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",
  "names": []
}
